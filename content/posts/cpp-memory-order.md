+++
title = '对 C++ Memory Order 不负责的理解'
date = 2024-03-15T22:15:28+08:00
draft = true
[params]
  author = "xiongjiwei"
  tags = ["CPP", "memory order"]
+++

### Memory order 是什么

我们的目标是促进 UTF-8 编码的使用和支持，并推广它成为内存、磁盘存储和通信等用途的默认文本字符串编码。我们相信，这种做法可以提高性能，降低软件的复杂性，并有助于避免多种 Unicode 相关的 bug。我们建议 Unicode（或广义来说，所有文本）的其他编码方式只应该用于少量需要性能优化的情况，主流用户应当避免接触。

一个具体的例子是非常流行的 UTF-16 编码（在 Windows 世界常常误称为“宽字符”或干脆称为“Unicode”）。我们认为它除了在 ICU 之类的专用文本处理库中可以使用以外，不应该在其他程序库的 API 中有一席之地。

### 背景
1988 年，Joseph D. Becker 发布了第一个 Unicode 提议草案。他的设计天真地建立在 16 比特就足够表示一个字符的假设上。1991 年，Unicode 标准（又名“统一码”、“万国码”）的第一个版本发布，但限制码位为 16 比特长。在随后的几年里，许多系统都增加了 Unicode 支持，并切换到了 UCS-2 编码。Unicode 尤其吸引当时的新技术，如 Qt 框架（1992）、Windows NT 3.1（1993）与 Java（1995）。

然而，人们很快发现每个字符 16 比特并不能满足 Unicode 的需求。1996年，为了确保现有的系统可以支持非 16 比特的字符，人们发明了 UTF-16。但是，它恰恰偏离了选择 16 比特定长编码的初衷。目前，Unicode 收录了超过 109449 个字符，其中大约有 74500 个中日韩表意文字。

### Memory order 如何影响程序行为
1988 年，Joseph D. Becker 发布了第一个 Unicode 提议草案。他的设计天真地建立在 16 比特就足够表示一个字符的假设上。1991 年，Unicode 标准（又名“统一码”、“万国码”）的第一个版本发布，但限制码位为 16 比特长。在随后的几年里，许多系统都增加了 Unicode 支持，并切换到了 UCS-2 编码。Unicode 尤其吸引当时的新技术，如 Qt 框架（1992）、Windows NT 3.1（1993）与 Java（1995）。

然而，人们很快发现每个字符 16 比特并不能满足 Unicode 的需求。1996年，为了确保现有的系统可以支持非 16 比特的字符，人们发明了 UTF-16。但是，它恰恰偏离了选择 16 比特定长编码的初衷。目前，Unicode 收录了超过 109449 个字符，其中大约有 74500 个中日韩表意文字。

### std::shared_ptr
1988 年，Joseph D. Becker 发布了第一个 Unicode 提议草案。他的设计天真地建立在 16 比特就足够表示一个字符的假设上。1991 年，Unicode 标准（又名“统一码”、“万国码”）的第一个版本发布，但限制码位为 16 比特长。在随后的几年里，许多系统都增加了 Unicode 支持，并切换到了 UCS-2 编码。Unicode 尤其吸引当时的新技术，如 Qt 框架（1992）、Windows NT 3.1（1993）与 Java（1995）。

然而，人们很快发现每个字符 16 比特并不能满足 Unicode 的需求。1996年，为了确保现有的系统可以支持非 16 比特的字符，人们发明了 UTF-16。但是，它恰恰偏离了选择 16 比特定长编码的初衷。目前，Unicode 收录了超过 109449 个字符，其中大约有 74500 个中日韩表意文字。